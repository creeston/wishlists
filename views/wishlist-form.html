
{{ block "wishlist-form" . }}
<form 
  x-data="wishlistFormData()"
  {{ if .HasId }}
  hx-put="/wishlist/{{ .Id }}"
  {{ else }}
  hx-post="/wishlist"
  {{ end }}
  @htmx:after-request="onFormSubmit($event)" 
  hx-swap="outerHTML"
>
  <div class="list-inputs" x-init="initializeFormValues()">
    <template x-for="(input, index) in inputs" :key="index" x-effect="inputs && $nextTick(() => initializeSpanWidths())">
      <div class="input-row">
        <span :class="{'invisible': !input || disabledInputs[index]}" x-text="(index + 1) + '.'"> </span>
        <div class="input-container">
          <input 
            :disabled="!isCreating || disabledInputs[index]" 
            :id="'input-' + index" 
            :class="{'crossed-text': disabledInputs[index]}"
            x-model="inputs[index]" 
            x-on:input="onInput($event, index)"
            x-on:keydown.enter.prevent="focusOnNextInputElement(index)"
            x-on:keydown.backspace="removeIfAlreadyEmpty(index)" :name="'item' + index" type="text"
            placeholder="Start typing..." 
          />
          <span :id="'input-hidden-span-' + index" class="hidden-span"></span>
        </div>
      </div>
    </template>
  </div>
  <script>
    function wishlistFormData() {
      return {
        inputs: [],
        disabledInputs: [],
        inputLengths: [],
        initializeFormValues() {
        {{ if .HasItems }}
          this.isSaveEnabled = true;
          this.inputs = [
          {{ range .Items }}
            "{{ .Text }}",
          {{ end }}
          ];
          this.disabledInputs = [
          {{ range .Items }}
            {{ .AlreadyChecked }},
          {{ end }}
          ];
          this.isCreating = false;
          this.wishlistId = {{ .Id }};
        {{ else}}
          this.inputs = [""];
          this.isCreating = true;
          this.isSaveEnabled = false;
         {{ end }}
          this.inputLengths = [0];
          this.$watch('isCreating', value => { 
            if (value) {
              if (this.inputs[-1] !== "") {
                this.addInput();
              }
            }
          });
        },
        initializeSpanWidths() {
          for (let i = 0; i < this.inputs.length; i++) {
            const input = document.getElementById("input-" + i);
            this.updateInputTextWidth(i, this.inputs[i], input);
          }
          const maxWidth = Math.max(...Object.values(this.inputLengths));
          const targetWidth = maxWidth + 120;
          listContainer.style.width = `${targetWidth}px`;
          capDiv.style.width = `${targetWidth + 70}px`;
        },
        focusOnNextInputElement(index) {
          const nextInput = document.getElementById("input-" + (index + 1));
          if (nextInput) {
            nextInput.focus();
          }
        },
        removeIfAlreadyEmpty(index) {
          if (this.inputs[index].trim() !== "") {
            return;
          }
    
          if (index === this.inputs.length - 1) {
            return;
          }
    
          this.inputs.splice(index, 1);
        },
        onInput(event, index) {
          this.isSaveEnabled = this.inputs.some(input => input.trim() !== "");
          const input = event.target;
          this.resizeInput(input, index);
        },
        resizeInput(input, index) {
          this.updateInputTextWidth(index, input.value, input);
          const maxWidth = Math.max(...Object.values(this.inputLengths));
          const targetWidth = maxWidth + 120;
          listContainer.style.width = `${targetWidth}px`;
          capDiv.style.width = `${targetWidth + 70}px`;
    
          if (this.inputs[index].trim() === "" && this.inputs.length > 1) {
            this.inputs.splice(index, 1);
            this.inputLengths.splice(index, 1);
          } else if (this.inputs.length === index + 1) {
            this.addInput();
          }
        },
        updateInputTextWidth(index, value, input) {
          const hiddenSpan = document.getElementById(
            "input-hidden-span-" + index
          );
          hiddenSpan.textContent = value;
          const computedStyle = window.getComputedStyle(input);
          hiddenSpan.style.fontSize = computedStyle.fontSize;
          hiddenSpan.style.fontFamily = computedStyle.fontFamily;
          hiddenSpan.style.fontWeight = computedStyle.fontWeight;
          hiddenSpan.style.letterSpacing = computedStyle.letterSpacing;
          hiddenSpan.style.textTransform = computedStyle.textTransform;
          this.inputLengths[index] = hiddenSpan.offsetWidth;
        },
        addInput() {
          this.inputs.push("");
          this.inputLengths.push(0);
        }
      };
    }
    </script>
</form>

{{ end }}